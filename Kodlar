import { useState, useEffect, useRef } from 'react';
import * as d3 from 'd3';

const LineChart = ({ initialData }) => {
    const svgRef = useRef();
    const [data, setData] = useState([]);

    useEffect(() => {
        const monthMap = {
            "Oca": "Jan",
            "Şub": "Feb",
            "Mar": "Mar",
            "Nis": "Apr",
            "May": "May",
            "Haz": "Jun",
            "Tem": "Jul",
            "Ağu": "Aug",
            "Eyl": "Sep",
            "Eki": "Oct",
            "Kas": "Nov",
            "Ara": "Dec"
        };

        const parseDate = d3.timeParse("%b-%y"); // "Kas-23" gibi formatı kabul eder

        // Veriyi tarih formatına çevirme
        const updatedData = initialData.map(d => {
            const englishMonth = monthMap[d.date.substring(0, 3)];
            const formattedDate = `${englishMonth}-${d.date.substring(4)}`; 
            const parsedDate = parseDate(formattedDate);

            return {
                date: parsedDate, 
                value1: d.value1,
                value2: d.value2
            };
        }).filter(d => d.date !== null);  

        setData(updatedData); // updatedData'yı state'e aktar

    }, [initialData]);  // initialData değiştiğinde useEffect tetiklenecek

    useEffect(() => {
        if (data.length === 0) return;

        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();
        const margin = { top: 20, right: 40, bottom: 100, left: 50 };
        const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
        const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;

        const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);

        // Y ekseninin üst sınırını biraz genişletmek için maksimum değerin üzerine ekleme yapalım
        const maxValue = d3.max(data, d => Math.max(d.value1, d.value2));
        const yMax = Math.ceil(maxValue / 20) * 20 + 20;

        const x = d3.scaleTime()
            .domain(d3.extent(data, d => d.date)) 
            .range([50, width]);

        const y = d3.scaleLinear()
            .domain([0, yMax])
            .nice()
            .range([height, 0]);

        const xAxis = d3.axisBottom(x)
            .tickValues(   // Her bir tarih sadece bir kez görünsün
                Array.from(new Set(data.map(d => d.date.getTime())))  
                    .map(d => new Date(d)) 
            )
            .tickFormat(d3.timeFormat("%b %d")) 
            .tickSize(0);

        const yAxis = d3.axisLeft(y)
            .tickValues(d3.range(0, yMax, 20)) 
            .tickSize(-width);  

        // Eksenlerin eklenmesi
        g.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0, ${height})`) 
            .call(xAxis);

        g.append('g')
            .attr('class', 'y-axis')
            .call(yAxis)
            .selectAll('.domain')  
            .remove();

        g.selectAll('.y-axis .tick line')
            .style('stroke', '#d3d3d3')
            .style('stroke-width', 1); 

        const line1 = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.value1));

        const line2 = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.value2));

        // Çizgilerin eklenmesi
        g.append('path')
            .data([data])
            .attr('class', 'line')
            .attr('d', line1)
            .attr('stroke', 'steelblue')
            .attr('fill', 'none')
            .attr('stroke-width', 2);

        g.append('path')
            .data([data])
            .attr('class', 'line')
            .attr('d', line2)
            .attr('stroke', 'orange')
            .attr('fill', 'none')
            .attr('stroke-width', 2);

        // Veri noktalarına yuvarlaklar ekleme (Value 1 için)
        g.selectAll('.circle1')
            .data(data)
            .enter()
            .append('circle')
            .attr('class', 'circle1')
            .attr('cx', d => x(d.date))
            .attr('cy', d => y(d.value1))
            .attr('r', 5)
            .attr('fill', 'steelblue');

        // Veri noktalarına yazı ekleme (Value 1 için)
        g.selectAll('.label1')
            .data(data)
            .enter()
            .append('text')
            .attr('class', 'label1')
            .attr('x', d => x(d.date))
            .attr('y', d => y(d.value1) - 10)
            .attr('text-anchor', 'middle')
            .style('fill', 'steelblue')
            .style('font-size', '10px')
            .text(d => d.value1);

        // Veri noktalarına yuvarlaklar ekleme (Value 2 için)
        g.selectAll('.circle2')
            .data(data)
            .enter()
            .append('circle')
            .attr('class', 'circle2')
            .attr('cx', d => x(d.date))
            .attr('cy', d => y(d.value2))
            .attr('r', 5)
            .attr('fill', 'orange');

        // Veri noktalarına yazı ekleme (Value 2 için)
        g.selectAll('.label2')
            .data(data)
            .enter()
            .append('text')
            .attr('class', 'label2')
            .attr('x', d => x(d.date))
            .attr('y', d => y(d.value2) - 10)
            .attr('text-anchor', 'middle')
            .style('fill', 'orange')
            .style('font-size', '10px')
            .text(d => d.value2);
    }, [data]); // data değiştiğinde çizimi yeniden yap

    return <svg ref={svgRef} width="100%" height="400px"></svg>;
};

export default LineChart;
